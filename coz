#!/usr/bin/env python3

# Copyright (c) 2019, Charlie Curtsinger and Emery Berger,
#                     University of Massachusetts Amherst
# This file is part of the Coz project. See LICENSE.md file at the top-level
# directory of this distribution and at http://github.com/plasma-umass/coz.

import argparse
import copy
import os
import subprocess
import sys

from os.path import abspath, realpath, curdir, dirname, sep as path_sep

# Entry point
def run_command_line():
  # By default, parse all arguments
  parsed_args = sys.argv[1:]
  remaining_args = []
  # If there is a '---' separator, only parse arguments before the separator
  if '---' in sys.argv:
    separator_index = sys.argv.index('---')
    parsed_args = sys.argv[1:separator_index]
    remaining_args = sys.argv[separator_index+1:]
  # Pass the un-parsed arguments to the parser result
  _parser.set_defaults(remaining_args=remaining_args)
  # Parse it
  args = _parser.parse_args(parsed_args)
  if not hasattr(args, 'func'):
    sys.stderr.write('error: pass a command before ---, such as `coz run --- $CMD`\n')
    _parser.print_help()
    sys.exit(1)

  # Call the parser's handler (set by the subcommand parser using defaults)
  args.func(args)

# Handler for the `coz run` subcommand
def _coz_run(args):
  # Ensure the user specified a command after the '---' separator
  if len(args.remaining_args) == 0:
    sys.stderr.write('error: specify a command to profile after `---`\n')
    args.parser.print_help()
    sys.exit(1)

  env = copy.deepcopy(os.environ)

  # Find coz
  coz_prefix = dirname(realpath(sys.argv[0]))

  # Candidate runtime library locations
  library_locations = [
    # Check for library adjacent to this script
    os.path.join(coz_prefix, '..', 'lib64', 'libcoz.so'),
    os.path.join(coz_prefix, '..', 'lib', 'libcoz.so'),

    # Check for library under the coz-profiler subdirectory
    os.path.join(coz_prefix, '..', 'lib64', 'coz-profiler', 'libcoz.so'),
    os.path.join(coz_prefix, '..', 'lib', 'coz-profiler', 'libcoz.so'),

    # Local library under development directory
    os.path.join('libcoz', 'libcoz.so'),      # Local library during development
    os.path.join(coz_prefix, 'libcoz', 'libcoz.so'),
    os.path.join(coz_prefix, 'build', 'libcoz', 'libcoz.so'),
  ]

  # Find the first library location that exists
  coz_runtime_found = False
  coz_runtime = None

  while len(library_locations) > 0 and not coz_runtime_found:
    candidate = library_locations.pop(0)
    if os.path.exists(candidate):
      coz_runtime_found = True
      coz_runtime = candidate

  # Allow environment variable to override library location
  if 'COZ_PRELOAD' in env:
    coz_runtime = env['COZ_PRELOAD']
    coz_runtime_found = True

  if not coz_runtime_found:
    sys.stderr.write('error: unable to locate coz runtime library\n')
    sys.exit(1)

  # Use DYLD_INSERT_LIBRARIES on macOS, LD_PRELOAD on Linux
  if sys.platform == 'darwin':
    preload_var = 'DYLD_INSERT_LIBRARIES'
  else:
    preload_var = 'LD_PRELOAD'

  if preload_var in env:
    env[preload_var] += ':' + coz_runtime
  else:
    env[preload_var] = coz_runtime

  if len(args.binary_scope) > 0:
    env['COZ_BINARY_SCOPE'] = '\t'.join(args.binary_scope)
  else:
    env['COZ_BINARY_SCOPE'] = 'MAIN'

  if len(args.source_scope) > 0:
    env['COZ_SOURCE_SCOPE'] = '\t'.join(args.source_scope)
  else:
    env['COZ_SOURCE_SCOPE'] = '%'

  env['COZ_PROGRESS_POINTS'] = '\t'.join(args.progress)

  env['COZ_OUTPUT'] = args.output

  if args.end_to_end:
    env['COZ_END_TO_END'] = '1'

  if args.fixed_line:
    env['COZ_FIXED_LINE'] = args.fixed_line

  if args.fixed_speedup != None:
    env['COZ_FIXED_SPEEDUP'] = str(args.fixed_speedup)

  if args.verbose:
    env['COZ_VERBOSE'] = '1'

  # JSON is now the default format
  if args.legacy_format:
    env['COZ_OUTPUT_FORMAT'] = 'legacy'
  else:
    env['COZ_OUTPUT_FORMAT'] = 'json'

  try:
    result = subprocess.call(args.remaining_args, env=env)
  except KeyboardInterrupt:
    # Exit with special control-C return code
    result = 130
    # Add a newline to mimic output when running without coz
    print()
  except FileNotFoundError:
    print(f"Error: Command not found: {args.remaining_args[0]}", file=sys.stderr)
    result = 127  # Standard "command not found" exit code
  except PermissionError:
    print(f"Error: Permission denied: {args.remaining_args[0]}", file=sys.stderr)
    result = 126  # Standard "permission denied" exit code
  exit(result)

def open_browser(url):
  import webbrowser
  webbrowser.open_new_tab(url)

def parse_profile(profile_path, include_raw=False):
  """Parse .coz or .jsonl profile and return aggregated data and metadata."""
  import json

  # Data structure: {selected_line: {progress_point: {speedup: {'delta': n, 'duration': n}}}}
  data = {}
  experiment_count = 0
  runtime = 0
  samples = {}
  raw_experiments = [] if include_raw else None

  with open(profile_path, 'r') as f:
    # Detect format from first line
    first_line = f.readline().strip()
    f.seek(0)

    is_json = first_line.startswith('{')

    experiment = None
    for line in f:
      line = line.strip()
      if not line:
        continue

      if is_json:
        # JSON Lines format
        try:
          record = json.loads(line)
        except json.JSONDecodeError:
          continue
        record_type = record.get('type', '')

        if record_type == 'experiment':
          experiment = {
            'selected': record.get('selected', ''),
            'speedup': float(record.get('speedup', 0)),
            'duration': int(record.get('duration', 0)),
            'selected_samples': int(record.get('selected_samples', 0))
          }
          experiment_count += 1
        elif record_type == 'throughput_point':
          if experiment:
            selected = experiment['selected']
            speedup = experiment['speedup']
            duration = experiment['duration']
            pp_name = record.get('name', '')
            delta = int(record.get('delta', 0))

            if selected not in data:
              data[selected] = {}
            if pp_name not in data[selected]:
              data[selected][pp_name] = {}
            if speedup not in data[selected][pp_name]:
              data[selected][pp_name][speedup] = {'delta': 0, 'duration': 0}

            data[selected][pp_name][speedup]['delta'] += delta
            data[selected][pp_name][speedup]['duration'] += duration

            if include_raw:
              raw_experiments.append({
                'selected': selected,
                'speedup': speedup,
                'duration': duration,
                'selected_samples': experiment['selected_samples'],
                'progress_point': pp_name,
                'delta': delta,
                'period': duration / delta if delta > 0 else None
              })
        elif record_type == 'runtime':
          runtime = int(record.get('time', 0))
        elif record_type == 'samples':
          loc = record.get('location', '')
          count = int(record.get('count', 0))
          samples[loc] = samples.get(loc, 0) + count
      else:
        # Legacy tab-separated format
        parts = line.split('\t')
        record_type = parts[0]
        fields = {}
        for part in parts[1:]:
          if '=' in part:
            k, v = part.split('=', 1)
            fields[k] = v

        if record_type == 'experiment':
          experiment = {
            'selected': fields.get('selected', ''),
            'speedup': float(fields.get('speedup', 0)),
            'duration': int(fields.get('duration', 0)),
            'selected_samples': int(fields.get('selected-samples', 0))
          }
          experiment_count += 1
        elif record_type in ('throughput-point', 'progress-point'):
          if experiment:
            selected = experiment['selected']
            speedup = experiment['speedup']
            duration = experiment['duration']
            pp_name = fields.get('name', '')
            delta = int(fields.get('delta', 0))

            if selected not in data:
              data[selected] = {}
            if pp_name not in data[selected]:
              data[selected][pp_name] = {}
            if speedup not in data[selected][pp_name]:
              data[selected][pp_name][speedup] = {'delta': 0, 'duration': 0}

            data[selected][pp_name][speedup]['delta'] += delta
            data[selected][pp_name][speedup]['duration'] += duration

            if include_raw:
              raw_experiments.append({
                'selected': selected,
                'speedup': speedup,
                'duration': duration,
                'selected_samples': experiment['selected_samples'],
                'progress_point': pp_name,
                'delta': delta,
                'period': duration / delta if delta > 0 else None
              })
        elif record_type == 'runtime':
          runtime = int(fields.get('time', 0))
        elif record_type == 'samples':
          loc = fields.get('location', '')
          count = int(fields.get('count', 0))
          samples[loc] = samples.get(loc, 0) + count

  return data, experiment_count, runtime, samples, raw_experiments

def calculate_speedups(data, min_points=1):
  """Calculate program speedup for each source line."""
  results = []
  for selected, progress_points in data.items():
    for pp_name, speedups in progress_points.items():
      # Find baseline: prefer 0% speedup, fall back to lowest speedup with delta > 0
      baseline = None
      baseline_speedup = None

      if 0.0 in speedups and speedups[0.0]['delta'] > 0:
        baseline_entry = speedups[0.0]
        baseline = baseline_entry['duration'] / baseline_entry['delta']
        baseline_speedup = 0.0
      else:
        # Fall back to lowest speedup with valid data
        for speedup in sorted(speedups.keys()):
          if speedups[speedup]['delta'] > 0:
            baseline_entry = speedups[speedup]
            baseline = baseline_entry['duration'] / baseline_entry['delta']
            baseline_speedup = speedup
            break

      if baseline is None:
        continue  # No valid baseline found

      measurements = []
      for speedup, agg in sorted(speedups.items()):
        if agg['delta'] == 0:
          continue
        data_point = agg['duration'] / agg['delta']
        progress_speedup = (baseline - data_point) / baseline
        measurements.append((speedup, progress_speedup))

      if len(measurements) >= min_points:
        # Calculate max speedup
        max_speedup = max(m[1] for m in measurements) if measurements else 0
        results.append({
          'line': selected,
          'progress_point': pp_name,
          'measurements': measurements,
          'max_speedup': max_speedup,
          'num_points': len(measurements),
          'baseline_speedup': baseline_speedup
        })

  # Sort by max speedup (highest first)
  results.sort(key=lambda x: x['max_speedup'], reverse=True)
  return results

def print_text_summary(profile_path, results, experiment_count, runtime, samples):
  """Print summary table of profiling results."""
  print(f"Profile: {profile_path}")
  runtime_sec = runtime / 1e9 if runtime > 0 else 0
  print(f"Experiments: {experiment_count} | Runtime: {runtime_sec:.1f}s")
  print()

  if not results:
    print("No profiling results found.")
    print("Make sure you specified a progress point and ran your program long enough.")
    return

  # Find max line width for formatting
  max_line_len = max(len(r['line']) for r in results)
  max_line_len = max(max_line_len, 11)  # "Source Line" header

  # Print header
  header = f"{'Source Line':<{max_line_len}} | Max Speedup | Points"
  print(header)
  print('-' * max_line_len + '-+-------------+-------')

  # Print each result
  for r in results:
    speedup_pct = r['max_speedup'] * 100
    sign = '+' if speedup_pct >= 0 else ''
    print(f"{r['line']:<{max_line_len}} | {sign}{speedup_pct:>9.1f}% | {r['num_points']:>5}")

def print_scatter_plot(result):
  """Print an ASCII scatter plot for a single result."""
  line = result['line']
  pp = result['progress_point']
  measurements = result['measurements']

  print()
  print(f"=== {line} -> {pp} ===")
  print()

  if not measurements:
    print("  No data points")
    return

  # Filter out extreme outliers (keep values in reasonable range -100% to +200%)
  filtered = [(x, y) for x, y in measurements if -1.0 <= y <= 2.0]
  if not filtered:
    filtered = measurements  # Fall back to all data if all are outliers

  # Find ranges
  min_speedup = min(m[1] for m in filtered)
  max_speedup = max(m[1] for m in filtered)

  # Expand range slightly for display
  if max_speedup == min_speedup:
    max_speedup = min_speedup + 0.1

  # Plot dimensions
  width = 60
  height = 15

  # Y-axis range: from min(0, min_speedup) to max_speedup
  y_min = min(0, min_speedup)
  y_max = max(max_speedup, 0.01)
  y_range = y_max - y_min

  # Create plot grid
  grid = [[' ' for _ in range(width)] for _ in range(height)]

  # Plot points (including outliers, clamped to grid)
  for line_speedup, prog_speedup in measurements:
    x = int(line_speedup * (width - 1))
    x = max(0, min(width - 1, x))
    # Clamp y to the visible range
    clamped_speedup = max(y_min, min(y_max, prog_speedup))
    y = int((clamped_speedup - y_min) / y_range * (height - 1))
    y = max(0, min(height - 1, y))
    y = height - 1 - y  # Flip Y axis
    grid[y][x] = '*'

  # Find zero line position
  zero_y = int((0 - y_min) / y_range * (height - 1))
  zero_y = height - 1 - zero_y
  zero_y = max(0, min(height - 1, zero_y))

  # Print plot
  print("Program")
  print("Speedup")
  for i, row in enumerate(grid):
    # Y-axis label
    y_val = y_max - (i / (height - 1)) * y_range
    label = f"{y_val*100:>6.0f}% |"
    line_str = ''.join(row)
    # Add zero line marker
    if i == zero_y:
      line_str = line_str.replace(' ', '-')
    print(f"{label}{line_str}")

  # X-axis
  print("        +" + "-" * width)
  print("        0%   20%   40%   60%   80%  100%")
  print("              Line Speedup")

def _output_json(output_path, profile_path, data, results, experiment_count,
                 runtime, samples, raw_experiments):
  """Output detailed experiment data as JSON for analysis."""
  import json

  output = {
    'profile_path': profile_path,
    'experiment_count': experiment_count,
    'runtime_ns': runtime,
    'runtime_sec': runtime / 1e9 if runtime > 0 else 0,

    # Sample counts by location
    'samples': samples,

    # Aggregated data by selected line -> progress point -> speedup
    'aggregated': {},

    # Calculated speedup results
    'results': [],

    # Raw experiment data for detailed analysis
    'raw_experiments': raw_experiments or []
  }

  # Convert aggregated data (speedup keys are floats, need string keys for JSON)
  for selected, pps in data.items():
    output['aggregated'][selected] = {}
    for pp, speedups in pps.items():
      output['aggregated'][selected][pp] = {}
      for speedup, agg in speedups.items():
        output['aggregated'][selected][pp][str(speedup)] = {
          'speedup_pct': speedup * 100,
          'delta': agg['delta'],
          'duration_ns': agg['duration'],
          'period_ns': agg['duration'] / agg['delta'] if agg['delta'] > 0 else None
        }

  # Convert results
  for r in results:
    # Calculate linear regression slope if we have enough points
    measurements = r['measurements']
    slope = None
    if len(measurements) >= 2:
      n = len(measurements)
      sum_x = sum(m[0] for m in measurements)
      sum_y = sum(m[1] for m in measurements)
      sum_xy = sum(m[0] * m[1] for m in measurements)
      sum_x2 = sum(m[0] ** 2 for m in measurements)
      denom = n * sum_x2 - sum_x ** 2
      if denom != 0:
        slope = (n * sum_xy - sum_x * sum_y) / denom

    result_entry = {
      'line': r['line'],
      'progress_point': r['progress_point'],
      'max_speedup': r['max_speedup'],
      'max_speedup_pct': r['max_speedup'] * 100,
      'num_points': r['num_points'],
      'slope': slope,
      'measurements': [
        {'line_speedup': ls, 'line_speedup_pct': ls * 100,
         'program_speedup': ps, 'program_speedup_pct': ps * 100}
        for ls, ps in r['measurements']
      ]
    }
    output['results'].append(result_entry)

  with open(output_path, 'w') as f:
    json.dump(output, f, indent=2)

  print(f"\nJSON output written to: {output_path}")

def _coz_plot_text(args):
  """Handle text-based profile output."""
  profile_path = abspath(args.input) if args.input else None
  if profile_path is None:
    # Prefer .jsonl if both exist
    for ext in ['profile.jsonl', 'profile.coz']:
      default_profile = abspath(curdir + path_sep + ext)
      if os.path.exists(default_profile):
        profile_path = default_profile
        break

  if not profile_path or not os.path.exists(profile_path):
    sys.stderr.write('error: no profile found. Specify with -i or run from directory with profile.coz or profile.jsonl\n')
    sys.exit(1)

  data, experiment_count, runtime, samples, raw_experiments = parse_profile(profile_path, include_raw=True)
  results = calculate_speedups(data)

  # Only print text output if --text is specified or --json is not specified
  if args.text or not args.json:
    print_text_summary(profile_path, results, experiment_count, runtime, samples)

    if args.verbose and results:
      print()
      print("=" * 70)
      print("DETAILED SCATTER PLOTS")
      print("=" * 70)
      for r in results:
        print_scatter_plot(r)

  # Output JSON if requested
  if args.json:
    _output_json(args.json, profile_path, data, results, experiment_count,
                 runtime, samples, raw_experiments)

def _find_viewer_directory():
  """Find the viewer directory relative to this script's location."""
  coz_prefix = dirname(realpath(sys.argv[0]))

  # Candidate viewer locations
  viewer_locations = [
    # Development: viewer directory adjacent to script
    os.path.join(coz_prefix, 'viewer'),

    # Installed: share/coz/viewer relative to bin
    os.path.join(coz_prefix, '..', 'share', 'coz', 'viewer'),
  ]

  for candidate in viewer_locations:
    index_path = os.path.join(candidate, 'index.htm')
    if os.path.exists(index_path):
      return abspath(candidate)

  return None

def _coz_plot(args):
  # Handle text-based output mode or JSON-only output
  if args.text or args.json:
    _coz_plot_text(args)
    return

  import http.server
  import socketserver
  import threading
  import urllib.parse

  viewer_dir = _find_viewer_directory()

  if viewer_dir is None:
    # Fall back to online viewer
    sys.stderr.write('warning: could not find local viewer, opening online viewer\n')
    coz_plot_url = 'https://coz-profiler.github.io/coz-ui/'
    t1 = threading.Thread(target=open_browser, args=(coz_plot_url,))
    t1.start()
    return

  # Check for profile.coz or profile.jsonl in current directory (or use specified input file)
  profile_path = abspath(args.input) if args.input else None
  if profile_path is None:
    # Prefer .jsonl if both exist
    for ext in ['profile.jsonl', 'profile.coz']:
      default_profile = abspath(curdir + path_sep + ext)
      if os.path.exists(default_profile):
        profile_path = default_profile
        break

  # Find an available port
  port = args.port

  class CozHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
      super().__init__(*args, directory=viewer_dir, **kwargs)

    def do_GET(self):
      # Serve profile.coz from current directory when requested
      if self.path == '/current-profile.coz' and profile_path:
        try:
          with open(profile_path, 'rb') as f:
            content = f.read()
          self.send_response(200)
          self.send_header('Content-Type', 'text/plain')
          self.send_header('Content-Length', len(content))
          self.end_headers()
          self.wfile.write(content)
          return
        except Exception as e:
          self.send_error(404, f'Profile not found: {e}')
          return
      # Default handler for other files
      super().do_GET()

    def log_message(self, format, *args):
      # Suppress default logging
      pass

  try:
    with socketserver.TCPServer(("", port), CozHandler) as httpd:
      # Build URL with query parameter if profile exists
      if profile_path:
        url = f'http://localhost:{port}/?load=current-profile.coz'
        print(f'Loading profile: {profile_path}')
      else:
        url = f'http://localhost:{port}/'
      print(f'Serving coz viewer at http://localhost:{port}/')
      print(f'Press Ctrl+C to stop the server')

      # Open browser in a separate thread
      t1 = threading.Thread(target=open_browser, args=(url,))
      t1.start()

      try:
        httpd.serve_forever()
      except KeyboardInterrupt:
        print('\nShutting down server...')
  except OSError as e:
    if e.errno == 48 or e.errno == 98:  # Address already in use (macOS/Linux)
      sys.stderr.write(f'error: port {port} is already in use. Try --port <number>\n')
      sys.exit(1)
    raise
  

# Special format handler for line reference arguments
def line_ref(val):
  try:
    (filename, line) = val.rsplit(':', 1)
    line = int(line)
    return filename + ':' + str(line)
  except:
    msg = "Invalid line reference %r. The format is <source file>:<line number>." % val
    raise argparse.ArgumentTypeError(msg)

######### Build the top-level parser #########
_parser = argparse.ArgumentParser()
_subparsers = _parser.add_subparsers()

######### Build the parser for the `run` sub-command #########
_run_parser = _subparsers.add_parser('run',
                                     usage='%(prog)s [profiling options] --- <command> [args]',
                                     help='Run a program with coz to collect a causal profile.')

# Add common profiler options
_run_parser.add_argument('--binary-scope', '-b',
                         metavar='<file pattern>',
                         default=[], action='append',
                         help='Profile matching executables. Use \'%%\' as a wildcard, or \'MAIN\' to include the main executable (default=MAIN)')

_run_parser.add_argument('--source-scope', '-s',
                         metavar='<file pattern>',
                         default=[], action='append',
                         help='Profile matching source files. Use \'%%\' as a wildcard. (default=%%)')

_run_parser.add_argument('--progress', '-p',
                         metavar='<source file>:<line number>',
                         type=line_ref, action='append', default=[],
                         help='[NOT SUPPORTED] Add a sampling-based progress point')

_run_parser.add_argument('--output', '-o',
                         metavar='<profile output>',
                         default=abspath(curdir+path_sep+'profile.jsonl'),
                         help='Profiler output (default=`profile.jsonl`)')

_run_parser.add_argument('--end-to-end',
                         action='store_true', default=False,
                         help='Run a single performance experiment per-execution')

_run_parser.add_argument('--fixed-line',
                         metavar='<source file>:<line number>', default=None,
                         help='Evaluate optimizations of a specific source line')

_run_parser.add_argument('--fixed-speedup',
                         metavar='<speedup> (0-100)',
                         type=int, choices=list(range(0, 101)), default=None,
                         help='Evaluate optimizations of a specific amount')

_run_parser.add_argument('--verbose', '-v',
                         action='store_true', default=False,
                         help='Print verbose output (libraries loaded, debug info found, etc.)')

_run_parser.add_argument('--legacy-format',
                         action='store_true', default=False,
                         help='Output profile in legacy tab-separated format (.coz extension)')

# Use defaults to recover handler function and parser object from parser output
_run_parser.set_defaults(func=_coz_run, parser=_run_parser)

######### Build the parser for the `coz plot` subcommand
_plot_parser = _subparsers.add_parser('plot',
                                      help='Plot the speedup results from one or more causal profiling runs.')

_plot_parser.add_argument('--input', '-i',
                          metavar='<profile.coz>',
                          default=None,
                          help='Profile file to load (default: profile.coz in current directory if present)')

_plot_parser.add_argument('--port', '-p',
                          metavar='<port>',
                          type=int, default=8080,
                          help='Port for the local web server (default=8080)')

_plot_parser.add_argument('--text', '-t',
                          action='store_true', default=False,
                          help='Output text-based graphs instead of web viewer')

_plot_parser.add_argument('--verbose', '-v',
                          action='store_true', default=False,
                          help='Show detailed scatter plots for each source line (with --text)')

_plot_parser.add_argument('--json', '-j',
                          metavar='<output.json>',
                          default=None,
                          help='Output detailed experiment data as JSON for analysis')

# Use defaults to recover handler function and parser object from parser output
_plot_parser.set_defaults(func=_coz_plot, parser=_plot_parser)

if __name__ == "__main__":
  run_command_line()
